ByteReader = (() => { try { return require("../scripts/ByteReader.js"); } catch {} } )() ?? ByteReader;
zlib = (() => { try { return require("zlib"); } catch {} } )() ?? zlib;

// fury
function ZIP (bytes) {

    // create byte reader
    const reader = new ByteReader(bytes);

    // zip (fury) -> this part was 90% generated by chatgpt because fuck this shit
    this.Signature === "PKZIP";
    this.Files = [];

    while (reader.index < bytes.length) {

        const sig = reader.uint32();

        if (sig !== 0x04034b50) break;

        const version = reader.uint16();
        const flags = reader.uint16();
        const compression = reader.uint16();
        const time = reader.uint16();
        const date = reader.uint16();
        const crc32 = reader.uint32();
        const compressedSize = reader.uint32();
        const uncompressedSize = reader.uint32();
        const nameLength = reader.uint16();
        const extraLength = reader.uint16();

        const name = reader.readString(nameLength);
        reader.index += extraLength;

        const compressedData = reader.read(compressedSize);
        let uncompressedData = null;

        if (compression === 0) {
            uncompressedData = compressedData;
        } else if (compression === 8) {
            uncompressedData = zlib.inflateRawSync(Buffer.from(compressedData));
        } else {
            throw new Error("Unsupported compression type: " + compression);
        }

        this.Files.push({
            name: name,
            size: uncompressedData.length,
            bytes: uncompressedData
        });

    }

    this.Serialize = () => {

        let writerLength = 0;
        let centralDirLength = 0;

        for (const file of this.Files) {
            const nameBytes = Buffer.from(file.name, "utf8");
            const content = Buffer.from(file.bytes);
            const deflated = zlib.deflateRawSync(content);
            const compressedLength = deflated.length;
            writerLength += 30 + nameBytes.length + compressedLength;
            centralDirLength += 46 + nameBytes.length;
        }

        // EOCD (End of Central Directory Record)
        writerLength += centralDirLength + 22;

        const writer = new ByteWriter(writerLength);
        const centralDirectory = new ByteWriter(centralDirLength);

        const localOffsets = [];
        let offset = 0;

        for (const file of this.Files) {

            const nameBytes = Array.from(Buffer.from(file.name));
            const content = Buffer.from(file.bytes);
            const deflated = zlib.deflateRawSync(content);
            const compressed = deflated;
            const compression = 8;

            localOffsets.push(offset);

            // local file header
            writer.int32(0x04034b50); // signature
            writer.int16(20); // version needed
            writer.int16(0);  // general purpose bit flag
            writer.int16(compression); // compression method
            writer.int16(0); // mod time
            writer.int16(0); // mod date
            writer.int32(0); // CRC32 (0 por simplicidade)
            writer.int32(compressed.length);
            writer.int32(content.length);
            writer.int16(nameBytes.length);
            writer.int16(0); // extra field length
            writer.write(nameBytes);
            writer.write(compressed);

            offset = writer.bytes.length;

            // central directory
            centralDirectory.int32(0x02014b50); // central dir sig
            centralDirectory.int16(0x0317); // made by
            centralDirectory.int16(20); // version needed
            centralDirectory.int16(0);  // flags
            centralDirectory.int16(compression);
            centralDirectory.int16(0); // mod time
            centralDirectory.int16(0); // mod date
            centralDirectory.int32(0); // CRC32
            centralDirectory.int32(compressed.length);
            centralDirectory.int32(content.length);
            centralDirectory.int16(nameBytes.length);
            centralDirectory.int16(0); // extra length
            centralDirectory.int16(0); // comment length
            centralDirectory.int16(0); // disk number start
            centralDirectory.int16(0); // internal attrs
            centralDirectory.int32(0); // external attrs
            centralDirectory.int32(localOffsets[localOffsets.length - 1]); // offset
            centralDirectory.write(nameBytes);

        }

        const centralOffset = writer.bytes.length;
        writer.write(centralDirectory.bytes);
        const centralSize = writer.bytes.length - centralOffset;

        // end of central directory
        writer.int32(0x06054b50);
        writer.int16(0); // disk number
        writer.int16(0); // start disk
        writer.int16(this.Files.length);
        writer.int16(this.Files.length);
        writer.int32(centralSize);
        writer.int32(centralOffset);
        writer.int16(0); // comment length

        return writer.bytes;

    };

}

try { module.exports = ZIP; } catch {}