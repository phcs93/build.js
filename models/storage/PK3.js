// pk3 (zip) -> code 90% generated by chatgpt
Build.Models.Storage.PK3 = class PK3 extends Build.Models.Storage {

    // create empty pk3 object
    constructor() {
        super();    
    }

    // transform byte array into pk3 object
    static Unserialize (bytes) {

        // create empty pk3 object
        const pk3 = new PK3();

        // create byte reader
        const reader = new Build.Scripts.ByteReader(bytes);
        
        pk3.Signature === "PK3";
        pk3.Files = [];

        while (reader.index < bytes.length) {

            const sig = reader.uint32();

            if (sig !== 0x04034b50) break;

            const version = reader.uint16();
            const flags = reader.uint16();
            const compression = reader.uint16();
            const time = reader.uint16();
            const date = reader.uint16();
            const crc32 = reader.uint32();
            const compressedSize = reader.uint32();
            const uncompressedSize = reader.uint32();
            const nameLength = reader.uint16();
            const extraLength = reader.uint16();

            const name = reader.string(nameLength);
            reader.index += extraLength;

            const compressedData = reader.read(compressedSize);
            let uncompressedData = null;

            if (compression === 0) {
                uncompressedData = compressedData;
            } else if (compression === 8) {
                uncompressedData = (new Build.Scripts.ZLIB.RawInflate(compressedData)).decompress();
            } else {
                throw new Error("Unsupported compression type: " + compression);
            }

            pk3.Files.push({
                name: name,
                size: uncompressedData.length,
                bytes: uncompressedData
            });

        }

        // return filled pk3 object
        return pk3;

    }

    // transform pk3 into byte array
    static Serialize (pk3) {

        let writerLength = 0;
        let centralDirLength = 0;

        const deflatedFiles = [];

        for (const i in pk3.Files) {
            const file = pk3.Files[i];
            const nameBytes = new TextEncoder().encode(file.name);
            const content = new Uint8Array(file.bytes);
            // the following line is VERY slow
            const deflated = (new Build.Scripts.ZLIB.RawDeflate(content)).compress();
            deflatedFiles[i] = deflated;
            const compressedLength = deflated.length;
            writerLength += 30 + nameBytes.length + compressedLength;
            centralDirLength += 46 + nameBytes.length;
        }

        writerLength += centralDirLength + 22;

        const writer = new Build.Scripts.ByteWriter(writerLength);
        const centralDirectory = new Build.Scripts.ByteWriter(centralDirLength);

        const localOffsets = [];
        let offset = 0;

        for (const i in pk3.Files) {

            const file = pk3.Files[i];

            const nameBytes = new TextEncoder().encode(file.name);
            const content = new Uint8Array(file.bytes);
            const deflated = deflatedFiles[i];
            const compressed = deflated;
            const compression = 8;

            localOffsets.push(offset);

            // local file header
            writer.int32(0x04034b50); // signature
            writer.int16(20); // version needed
            writer.int16(0);  // general purpose bit flag
            writer.int16(compression); // compression method
            writer.int16(0); // mod time
            writer.int16(0); // mod date
            writer.int32(0); // CRC32 (0 por simplicidade)
            writer.int32(compressed.length);
            writer.int32(content.length);
            writer.int16(nameBytes.length);
            writer.int16(0); // extra field length
            writer.write(nameBytes);
            writer.write(compressed);

            offset = writer.bytes.length;

            // central directory
            centralDirectory.int32(0x02014b50); // central dir sig
            centralDirectory.int16(0x0317); // made by
            centralDirectory.int16(20); // version needed
            centralDirectory.int16(0);  // flags
            centralDirectory.int16(compression);
            centralDirectory.int16(0); // mod time
            centralDirectory.int16(0); // mod date
            centralDirectory.int32(0); // CRC32
            centralDirectory.int32(compressed.length);
            centralDirectory.int32(content.length);
            centralDirectory.int16(nameBytes.length);
            centralDirectory.int16(0); // extra length
            centralDirectory.int16(0); // comment length
            centralDirectory.int16(0); // disk number start
            centralDirectory.int16(0); // internal attrs
            centralDirectory.int32(0); // external attrs
            centralDirectory.int32(localOffsets[localOffsets.length - 1]); // offset
            centralDirectory.write(nameBytes);

        }

        const centralOffset = writer.bytes.length;
        writer.write(centralDirectory.bytes);
        const centralSize = writer.bytes.length - centralOffset;

        // end of central directory
        writer.int32(0x06054b50);
        writer.int16(0); // disk number
        writer.int16(0); // start disk
        writer.int16(pk3.Files.length);
        writer.int16(pk3.Files.length);
        writer.int32(centralSize);
        writer.int32(centralOffset);
        writer.int16(0); // comment length

        return writer.bytes;

    }

}