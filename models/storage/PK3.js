ByteReader = (() => { try { return require("../../scripts/ByteReader.js"); } catch {} } )() ?? ByteReader;
ByteWriter = (() => { try { return require("../../scripts/ByteWriter.js"); } catch {} } )() ?? ByteWriter;
zlib = (() => { try { return require("zlib"); } catch {} } )() ?? zlib;

// pk3 (zip) -> code 90% generated by chatgpt
class PK3 {

    constructor (bytes) {

        // create byte reader
        const reader = new ByteReader(bytes);
        
        this.Signature === "PK3";
        this.Files = [];

        while (reader.index < bytes.length) {

            const sig = reader.uint32();

            if (sig !== 0x04034b50) break;

            const version = reader.uint16();
            const flags = reader.uint16();
            const compression = reader.uint16();
            const time = reader.uint16();
            const date = reader.uint16();
            const crc32 = reader.uint32();
            const compressedSize = reader.uint32();
            const uncompressedSize = reader.uint32();
            const nameLength = reader.uint16();
            const extraLength = reader.uint16();

            const name = reader.string(nameLength);
            reader.index += extraLength;

            const compressedData = reader.read(compressedSize);
            let uncompressedData = null;

            if (compression === 0) {
                uncompressedData = compressedData;
            } else if (compression === 8) {
                uncompressedData = zlib.inflateRawSync(Buffer.from(compressedData));
            } else {
                throw new Error("Unsupported compression type: " + compression);
            }

            this.Files.push({
                name: name,
                size: uncompressedData.length,
                bytes: uncompressedData
            });

        }

    }

    Serialize () {

        let writerLength = 0;
        let centralDirLength = 0;

        const deflatedFiles = [];

        for (const i in this.Files) {
            const file = this.Files[i];
            const nameBytes = Array.from(Buffer.from(file.name));
            const content = Buffer.from(file.bytes);
            const deflated = zlib.deflateRawSync(content);
            deflatedFiles[i] = deflated;
            const compressedLength = deflated.length;
            writerLength += 30 + nameBytes.length + compressedLength;
            centralDirLength += 46 + nameBytes.length;
        }

        writerLength += centralDirLength + 22;

        const writer = new ByteWriter(writerLength);
        const centralDirectory = new ByteWriter(centralDirLength);

        const localOffsets = [];
        let offset = 0;

        for (const i in this.Files) {

            const file = this.Files[i];

            const nameBytes = Array.from(Buffer.from(file.name));
            const content = Buffer.from(file.bytes);
            //const deflated = zlib.deflateRawSync(content);
            const deflated = deflatedFiles[i];
            const compressed = deflated;
            const compression = 8;

            localOffsets.push(offset);

            // local file header
            writer.int32(0x04034b50); // signature
            writer.int16(20); // version needed
            writer.int16(0);  // general purpose bit flag
            writer.int16(compression); // compression method
            writer.int16(0); // mod time
            writer.int16(0); // mod date
            writer.int32(0); // CRC32 (0 por simplicidade)
            writer.int32(compressed.length);
            writer.int32(content.length);
            writer.int16(nameBytes.length);
            writer.int16(0); // extra field length
            writer.write(nameBytes);
            writer.write(compressed);

            offset = writer.bytes.length;

            // central directory
            centralDirectory.int32(0x02014b50); // central dir sig
            centralDirectory.int16(0x0317); // made by
            centralDirectory.int16(20); // version needed
            centralDirectory.int16(0);  // flags
            centralDirectory.int16(compression);
            centralDirectory.int16(0); // mod time
            centralDirectory.int16(0); // mod date
            centralDirectory.int32(0); // CRC32
            centralDirectory.int32(compressed.length);
            centralDirectory.int32(content.length);
            centralDirectory.int16(nameBytes.length);
            centralDirectory.int16(0); // extra length
            centralDirectory.int16(0); // comment length
            centralDirectory.int16(0); // disk number start
            centralDirectory.int16(0); // internal attrs
            centralDirectory.int32(0); // external attrs
            centralDirectory.int32(localOffsets[localOffsets.length - 1]); // offset
            centralDirectory.write(nameBytes);

        }

        const centralOffset = writer.bytes.length;
        writer.write(centralDirectory.bytes);
        const centralSize = writer.bytes.length - centralOffset;

        // end of central directory
        writer.int32(0x06054b50);
        writer.int16(0); // disk number
        writer.int16(0); // start disk
        writer.int16(this.Files.length);
        writer.int16(this.Files.length);
        writer.int32(centralSize);
        writer.int32(centralOffset);
        writer.int16(0); // comment length

        return writer.bytes;

    }

}

try { module.exports = PK3; } catch {}